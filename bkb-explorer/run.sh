#!/bin/bash

# BKB Explorer Batch Processor
# Process ontology data from input to output and generate JS bundles

set -e  # Exit on error

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Initialize input directory symbolic links
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/init-input.sh" ]; then
    "$SCRIPT_DIR/init-input.sh"
    echo ""
else
    echo -e "${RED}Error: init-input.sh not found${NC}"
    exit 1
fi

# Default values
INPUT_DIR="input"
OUTPUT_DIR="output"
JS_DIR="js"
MODE="all"
FORCE="false"

# Show usage
show_usage() {
    cat << EOF
${BLUE}BKB Explorer Batch Processor${NC}

Usage:
  $0 [MODE] [OPTIONS]

Modes:
  domain <path>     Process single domain (e.g., Test or RBCZ:MIB:Investment)
  all               Process all domains (default)

Options:
  -f, --force       Force regeneration even if data is up-to-date
  -i, --input DIR   Input directory (default: input)
  -o, --output DIR  Output directory (default: output)
  -h, --help        Show this help

Examples:
  # Single domain
  $0 domain Test
  $0 domain RBCZ:MIB:Investment

  # All domains
  $0 all
  $0                # same as 'all'

EOF
    exit 0
}

# Parse arguments
SINGLE_DOMAIN=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            ;;
        -f|--force)
            FORCE="true"
            shift
            ;;
        domain)
            MODE="domain"
            shift
            SINGLE_DOMAIN="$1"
            if [ -z "$SINGLE_DOMAIN" ]; then
                echo -e "${RED}Error: domain mode requires a domain path${NC}"
                echo "Usage: $0 domain <path>"
                exit 1
            fi
            shift
            ;;
        all)
            MODE="all"
            shift
            ;;
        -i|--input)
            INPUT_DIR="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            show_usage
            ;;
    esac
done

# Function to convert domain path to filesystem path
# RBCZ:MIB:Investment → RBCZ/MIB/Investment
domain_to_path() {
    echo "$1" | tr ':' '/'
}

# Function to convert filesystem path to domain path
# RBCZ/MIB/Investment → RBCZ:MIB:Investment
path_to_domain() {
    echo "$1" | tr '/' ':'
}

# Function to get domain JS variable name
# Test → test
# RBCZ:MIB:Investment → investment
get_domain_js_name() {
    local domain_path="$1"
    # Get last segment and convert to lowercase
    echo "$domain_path" | tr ':' '\n' | tail -1 | tr '[:upper:]' '[:lower:]'
}

# Function to process single domain
process_domain() {
    local domain_path="$1"
    local fs_path=$(domain_to_path "$domain_path")
    local input_file="$INPUT_DIR/$fs_path/ontology.json"
    local output_dir="$OUTPUT_DIR/$fs_path"
    local output_file="$output_dir/ontology.json"
    local js_name=$(get_domain_js_name "$domain_path")
    local js_dir="$JS_DIR/$fs_path"
    local js_file="$js_dir/data.js"

    echo -e "${GREEN}Processing domain: $domain_path${NC}"
    echo "Input:  $input_file"
    echo "Output: $output_file"
    echo "JS:     $js_file"
    echo ""

    # Check if input file exists
    if [ ! -f "$input_file" ]; then
        echo -e "${YELLOW}Warning: Input file not found: $input_file${NC}"
        return 1
    fi

    # Freshness check - skip if data.js is up-to-date (ADR-071)
    if [ -f "$js_file" ] && [ "$FORCE" != "true" ]; then
        local input_mtime=$(stat -f %m "$input_file" 2>/dev/null || echo 0)
        local output_mtime=$(stat -f %m "$js_file" 2>/dev/null || echo 0)
        if [ "$output_mtime" -ge "$input_mtime" ]; then
            echo -e "  ${BLUE}ℹ${NC} data.js is up-to-date (use --force to regenerate)"
            return 0
        fi
    fi

    # Ensure output and JS directories exist
    mkdir -p "$output_dir"
    mkdir -p "$js_dir"

    # Copy ontology.json to output
    cp "$input_file" "$output_file"
    echo -e "  ${GREEN}✓${NC} Copied ontology.json"

    # Generate JS bundle
    python3 << PYTHON
import json
from datetime import datetime

# Variables from bash
js_name = '$js_name'
domain_path = '$domain_path'
output_file = '$output_file'
js_file = '$js_file'

# Load ontology data
with open(output_file) as f:
    data = json.load(f)

# Extract domain info
domain_info = data.get('domain', {})
domain_name = domain_info.get('name', js_name)
concept_count = len(data.get('concepts', []))
external_count = len(data.get('external_concepts', []))

# Generate JS file
js_content = f'''/**
 * BKB Explorer - {domain_name} Domain Data
 *
 * Auto-generated by run.sh
 * Domain: {domain_path}
 * Concepts: {concept_count}
 * External: {external_count}
 *
 * Generated: {datetime.now().isoformat()}
 */

// Lazy-loaded domain data
window.BKB_LOADED = {json.dumps(data, indent=2)};

console.log('✅ Loaded {domain_name}:', {concept_count} + {external_count}, 'concepts');
'''

# Write JS file
with open(js_file, 'w') as f:
    f.write(js_content)

print(f"  ✓ Generated {js_name}.js ({concept_count} + {external_count} concepts)")
PYTHON

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Success: $domain_path${NC}"
        return 0
    else
        echo -e "${RED}✗ Failed: $domain_path${NC}"
        return 1
    fi
}

# Function to discover all domains
discover_domains() {
    local input_dir="$1"

    if [ ! -d "$input_dir" ]; then
        echo -e "${RED}Error: Input directory not found: $input_dir${NC}"
        exit 1
    fi

    # Find all ontology.json files
    local domains=()
    while IFS= read -r -d '' ontology_json; do
        # Get directory containing the ontology.json file
        local dir=$(dirname "$ontology_json")

        # Convert to domain path
        local relative_path="${dir#$input_dir/}"

        # Skip input directory itself
        [ -z "$relative_path" ] && continue

        # Add if not already in array
        if [[ ! " ${domains[@]} " =~ " ${relative_path} " ]]; then
            domains+=("$relative_path")
        fi
    done < <(find -L "$input_dir" -name "ontology.json" -type f -print0)

    # Sort unique domains
    printf '%s\n' "${domains[@]}" | sort -u
}

# Function to process all domains
process_all() {
    echo -e "${GREEN}Discovering domains in $INPUT_DIR...${NC}"
    echo ""

    local domains=($(discover_domains "$INPUT_DIR"))
    local total=${#domains[@]}

    if [ $total -eq 0 ]; then
        echo -e "${YELLOW}No domains found in $INPUT_DIR${NC}"
        return 0
    fi

    echo -e "${BLUE}Found $total domain(s):${NC}"
    for domain_fs_path in "${domains[@]}"; do
        local domain_path=$(path_to_domain "$domain_fs_path")
        echo "  • $domain_path"
    done
    echo ""

    # Process each domain
    local success=0
    local failed=0

    for domain_fs_path in "${domains[@]}"; do
        local domain_path=$(path_to_domain "$domain_fs_path")
        echo ""
        echo -e "${BLUE}[$((success + failed + 1))/$total]${NC}"

        if process_domain "$domain_path"; then
            success=$((success + 1))
        else
            failed=$((failed + 1))
        fi
    done

    # Summary
    echo ""
    echo -e "${BLUE}═══════════════════════════════════════${NC}"
    echo -e "${GREEN}✓ Success: $success${NC}"
    if [ $failed -gt 0 ]; then
        echo -e "${RED}✗ Failed:  $failed${NC}"
    fi
    echo -e "${BLUE}═══════════════════════════════════════${NC}"

    if [ $failed -gt 0 ]; then
        exit 1
    fi

    # Generate domains hierarchy
    echo ""
    echo -e "${GREEN}Generating domains hierarchy...${NC}"
    generate_domains_hierarchy
}

# Function to generate domains.js hierarchy file
generate_domains_hierarchy() {
    local hierarchy_file="$OUTPUT_DIR/domains.js"

    python3 << PYTHON
import json
import os
from datetime import datetime

input_dir = '$INPUT_DIR'
output_dir = '$OUTPUT_DIR'

# Find all ontology.json files (follow symlinks)
ontology_files = []
for root, dirs, files in os.walk(input_dir, followlinks=True):
    if 'ontology.json' in files:
        rel_path = os.path.relpath(root, input_dir)
        ontology_files.append(rel_path)

# Build hierarchy
def build_hierarchy(files):
    hierarchy = {}

    for file_path in files:
        parts = file_path.split('/')
        current = hierarchy
        full_path = []

        for i, part in enumerate(parts):
            full_path.append(part)
            is_last = i == len(parts) - 1
            path_str = '/'.join(full_path)

            if part not in current:
                current[part] = {
                    'type': 'domain' if is_last else 'folder',
                    'path': path_str
                }

            # Check if this level has ontology.json
            check_path = os.path.join(input_dir, path_str, 'ontology.json')
            if os.path.exists(check_path):
                current[part]['type'] = 'domain'
                # Add concept count
                with open(check_path) as f:
                    data = json.load(f)
                    concept_count = len(data.get('concepts', [])) + len(data.get('external_concepts', []))
                    current[part]['conceptCount'] = concept_count

            if not is_last:
                if 'children' not in current[part]:
                    current[part]['children'] = {}
                current = current[part]['children']

    return hierarchy

hierarchy = build_hierarchy(ontology_files)

# Generate domains data
domains_data = {
    'version': '2.0',
    'generated': datetime.now().isoformat(),
    'hierarchy': hierarchy
}

# Write domains.js
with open('$hierarchy_file', 'w') as f:
    f.write('''/**
 * BKB Explorer - Domains Hierarchy
 * Auto-generated by run.sh
 * DO NOT EDIT MANUALLY
 */
window.BKB_DOMAINS_DATA = ''')
    f.write(json.dumps(domains_data, indent=2))
    f.write(';\\n')

print(f"  ✓ Generated domains.js ({len(ontology_files)} domains)")
PYTHON

    if [ $? -eq 0 ]; then
        echo -e "  ${GREEN}✓${NC} $hierarchy_file"
    else
        echo -e "  ${RED}✗${NC} Failed to generate domains.js"
    fi
}

# Main execution
case $MODE in
    domain)
        process_domain "$SINGLE_DOMAIN"
        # BUG-011 FIX: Regenerate hierarchy after single domain processing
        echo ""
        echo -e "${GREEN}Regenerating domains hierarchy...${NC}"
        generate_domains_hierarchy
        ;;
    all)
        process_all
        ;;
    *)
        echo -e "${RED}Invalid mode: $MODE${NC}"
        show_usage
        ;;
esac
