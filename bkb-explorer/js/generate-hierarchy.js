#!/usr/bin/env node
/**
 * BKB Explorer - Hierarchy & Data Generator
 *
 * Generates:
 *   - output/domains.json (hierarchy only)
 *   - output/{domain-path}/data.js (per-domain data for lazy loading)
 *
 * Reads from input/ directory (symlink to ontology-lift/output)
 * Follows ADR-065 (Unified I/O Directory Convention)
 *
 * Usage: node js/generate-hierarchy.js
 */

const fs = require('fs');
const path = require('path');

const INPUT_DIR = path.join(__dirname, '..', 'input');
const OUTPUT_DIR = path.join(__dirname, '..', 'output');

console.log('BKB Explorer - Generating hierarchy and per-domain data...');
console.log(`Input:  ${INPUT_DIR}`);
console.log(`Output: ${OUTPUT_DIR}`);
console.log('');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

/**
 * Recursively find all ontology.json files
 * @param {string} dir - Directory to search
 * @param {string} basePath - Relative path from input root
 * @returns {Array<{path: string, relativePath: string}>}
 */
function findOntologyFiles(dir, basePath = '') {
  const results = [];

  if (!fs.existsSync(dir)) {
    return results;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = basePath ? `${basePath}/${entry.name}` : entry.name;

    if (entry.isDirectory() || entry.isSymbolicLink()) {
      // Check if this directory has ontology.json (it's a domain/view)
      const ontologyPath = path.join(fullPath, 'ontology.json');
      if (fs.existsSync(ontologyPath)) {
        results.push({
          path: ontologyPath,
          relativePath: basePath ? `${basePath}/${entry.name}` : entry.name,
        });
      }
      // Recurse into subdirectories
      results.push(...findOntologyFiles(fullPath, relativePath));
    }
  }

  return results;
}

/**
 * Build domain hierarchy from paths with concept counts
 * @param {Array} ontologyFiles - List of {path, relativePath, data}
 * @returns {Object} Hierarchy object
 */
function buildHierarchy(ontologyFiles) {
  const hierarchy = {};

  for (const file of ontologyFiles) {
    const parts = file.relativePath.split('/').filter(p => p);
    if (parts.length === 0) continue;

    let current = hierarchy;
    const fullPath = [];

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      fullPath.push(part);
      const isLast = i === parts.length - 1;
      const pathStr = fullPath.join('/');

      if (!current[part]) {
        current[part] = {
          type: isLast ? 'domain' : 'folder',
          path: pathStr,
        };
      }

      // Check if this level has ontology.json (making it a domain)
      const checkPath = path.join(INPUT_DIR, pathStr, 'ontology.json');
      if (fs.existsSync(checkPath)) {
        current[part].type = 'domain';
        // Add concept count
        const data = JSON.parse(fs.readFileSync(checkPath, 'utf-8'));
        const conceptCount = (data.concepts?.length || 0) + (data.external_concepts?.length || 0);
        current[part].conceptCount = conceptCount;
      }

      if (!isLast) {
        if (!current[part].children) {
          current[part].children = {};
        }
        current = current[part].children;
      }
    }
  }

  return hierarchy;
}

/**
 * Mirror directory structure exactly - no view conversion
 * Keep the hierarchy as-is from filesystem
 *
 * @param {Object} hierarchy - Built hierarchy
 */
function identifyViews(hierarchy) {
  // Do nothing - keep exact directory structure
  // This function is kept for compatibility but doesn't transform anything
}

/**
 * Generate per-domain data.js file
 * @param {string} relativePath - Domain path (e.g., "Test/Order")
 * @param {Object} data - Ontology data
 */
function generateDomainDataFile(relativePath, data) {
  const outputPath = path.join(OUTPUT_DIR, relativePath, 'data.js');
  const outputDir = path.dirname(outputPath);

  // Ensure directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate JS file that sets window.BKB_LOADED
  const content = `/**
 * BKB Explorer - Domain Data: ${relativePath.replace(/\//g, ':')}
 * Auto-generated by generate-hierarchy.js
 * DO NOT EDIT MANUALLY
 */
window.BKB_LOADED = ${JSON.stringify(data, null, 2)};
`;

  fs.writeFileSync(outputPath, content, 'utf-8');
  return outputPath;
}

// Main execution
const ontologyFiles = findOntologyFiles(INPUT_DIR);

console.log(`Found ${ontologyFiles.length} ontology.json file(s):`);
ontologyFiles.forEach(f => console.log(`  - ${f.relativePath}`));
console.log('');

if (ontologyFiles.length === 0) {
  console.log('No ontology.json files found in input/');
  console.log('Run the pipeline first or check symlinks.');
  process.exit(1);
}

// Build hierarchy
const hierarchy = buildHierarchy(ontologyFiles);
identifyViews(hierarchy, ontologyFiles);

// Generate domains.json
const domainsData = {
  version: '2.0',
  generated: new Date().toISOString(),
  hierarchy: hierarchy,
};

const domainsJsonPath = path.join(OUTPUT_DIR, 'domains.json');
fs.writeFileSync(domainsJsonPath, JSON.stringify(domainsData, null, 2), 'utf-8');
console.log(`Generated: ${domainsJsonPath}`);

// Also generate domains.js wrapper for file:// protocol support
const domainsJsPath = path.join(OUTPUT_DIR, 'domains.js');
const domainsJsContent = `/**
 * BKB Explorer - Domains Hierarchy
 * Auto-generated by generate-hierarchy.js
 * DO NOT EDIT MANUALLY
 */
window.BKB_DOMAINS_DATA = ${JSON.stringify(domainsData, null, 2)};
`;
fs.writeFileSync(domainsJsPath, domainsJsContent, 'utf-8');
console.log(`Generated: ${domainsJsPath}`);

// Generate per-domain data.js files
let generatedCount = 0;
for (const file of ontologyFiles) {
  const data = JSON.parse(fs.readFileSync(file.path, 'utf-8'));
  const outputPath = generateDomainDataFile(file.relativePath, data);
  const conceptCount = data.concepts?.length || 0;
  console.log(`Generated: ${file.relativePath}/data.js (${conceptCount} concepts)`);
  generatedCount++;
}

console.log('');
console.log(`Done! Generated ${generatedCount} domain data files.`);
console.log('');
console.log('Open index.html in browser to view the explorer.');
