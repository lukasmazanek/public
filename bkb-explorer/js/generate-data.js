#!/usr/bin/env node
/**
 * BKB Explorer - Data Generator from Pipeline Output
 *
 * Generates data.js from ontology-lift/output/ via input/ symlinks (ADR-065)
 *
 * Usage: node js/generate-data.js
 */

const fs = require('fs');
const path = require('path');

const INPUT_DIR = path.join(__dirname, '..', 'input');
const OUTPUT_FILE = path.join(__dirname, 'data.js');

console.log('BKB Explorer - Generating data.js from pipeline output...');
console.log(`Input: ${INPUT_DIR}`);
console.log('');

// Recursively find all ontology.json files
function findOntologyFiles(dir, basePath = '') {
  const results = [];

  if (!fs.existsSync(dir)) {
    return results;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = basePath ? `${basePath}/${entry.name}` : entry.name;

    if (entry.isDirectory() || entry.isSymbolicLink()) {
      // Recurse into subdirectories
      results.push(...findOntologyFiles(fullPath, relativePath));
    } else if (entry.name === 'ontology.json') {
      results.push({
        path: fullPath,
        relativePath: basePath,
      });
    }
  }

  return results;
}

// Build domain hierarchy from paths
function buildHierarchy(ontologyFiles) {
  const hierarchy = {};

  for (const file of ontologyFiles) {
    const parts = file.relativePath.split('/').filter(p => p);

    if (parts.length === 0) continue;

    let current = hierarchy;

    // Build nested structure
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];

      if (!current[part]) {
        // Last part is a view/subdomain, others are folders
        if (i === parts.length - 1) {
          current[part] = { type: 'view' };
        } else {
          current[part] = { type: 'folder', children: {} };
        }
      }

      if (i < parts.length - 1) {
        if (!current[part].children) {
          current[part].children = {};
        }
        current = current[part].children;
      }
    }
  }

  return hierarchy;
}

// Convert hierarchy to DOMAINS_DATA format
function formatHierarchy(hierarchy) {
  const result = {};

  for (const [name, node] of Object.entries(hierarchy)) {
    if (node.type === 'folder') {
      const children = {};
      const views = {};

      // Separate views from subdomains
      for (const [childName, childNode] of Object.entries(node.children || {})) {
        if (childNode.type === 'view') {
          views[childName] = {};
        } else {
          Object.assign(children, formatHierarchy({ [childName]: childNode }));
        }
      }

      result[name] = {
        type: Object.keys(views).length > 0 ? 'domain' : 'folder',
      };

      if (Object.keys(children).length > 0) {
        result[name].children = children;
      }

      if (Object.keys(views).length > 0) {
        result[name].views = views;
      }
    } else if (node.type === 'view') {
      // This is a view, parent should be a domain
      result[name] = {};
    }
  }

  return result;
}

// Main execution
const ontologyFiles = findOntologyFiles(INPUT_DIR);

console.log(`Found ${ontologyFiles.length} ontology.json file(s):`);
ontologyFiles.forEach(f => console.log(`  - ${f.relativePath}`));
console.log('');

if (ontologyFiles.length === 0) {
  console.log('⚠️  No ontology.json files found in input/');
  console.log('Run the pipeline first:');
  console.log('  miro-digest extract → conceptspeak parse → domain-forge consolidate → ontology-lift enrich');
  process.exit(1);
}

// Load all ontology data
const dataMap = {};
const hierarchy = buildHierarchy(ontologyFiles);

for (const file of ontologyFiles) {
  const data = JSON.parse(fs.readFileSync(file.path, 'utf-8'));
  const key = file.relativePath.replace(/\//g, '_').toLowerCase();
  dataMap[key] = data;

  console.log(`Loaded: ${file.relativePath} (${data.concepts?.length || 0} concepts)`);
}

console.log('');

// Generate data.js
const timestamp = new Date().toISOString();

let output = `/**
 * BKB Explorer - Pipeline Output Data
 *
 * Auto-generated by generate-data.js (ADR-065)
 * Source: ontology-lift/output/ via input/ symlinks
 * DO NOT EDIT MANUALLY
 *
 * Generated: ${timestamp}
 */

// Domain hierarchy
const DOMAINS_DATA = ${JSON.stringify({
  version: "1.0",
  hierarchy: formatHierarchy(hierarchy),
  crossDomain: {}
}, null, 2)};

`;

// Export individual datasets
for (const [key, data] of Object.entries(dataMap)) {
  const constName = key.toUpperCase() + '_DATA';
  output += `\nconst ${constName} = ${JSON.stringify(data, null, 2)};\n`;
}

// Build exports object
output += `\n// Export for application\nwindow.BKB_DATA = {\n  domains: DOMAINS_DATA`;

for (const key of Object.keys(dataMap)) {
  output += `,\n  ${key}: ${key.toUpperCase()}_DATA`;
}

output += `\n};\n\nconsole.log('BKB data loaded:', Object.keys(window.BKB_DATA));\n`;

// Write output
fs.writeFileSync(OUTPUT_FILE, output, 'utf-8');

console.log(`✅ Generated: ${OUTPUT_FILE}`);
console.log('');
console.log('Open index.html in browser to view the explorer.');
